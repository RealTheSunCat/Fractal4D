#version 430
//! layout(local_size_x = 16, local_size_y = 16) in; // this is inserted on load
layout(rgba32f, binding = 0) writeonly uniform image2D img_output;

//! #define RENDER_DIST 100

struct Camera
{
    vec3 pos;
    float cosYaw;
    float cosPitch;
    float sinYaw;
    float sinPitch;
    vec2 frustumDiv;
};

uniform Camera camera;
uniform vec2 screenSize;
uniform float time;

uniform vec3 color;

// thanks, http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl
vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// default: 8, min: 0, max: 30
#define NUM_ITERATIONS 8

// default: 6.0, min: 1.0, max: 16.0
#define EXPONENT 6.0


// return no more than distance to object
float distEst(vec3 pos)
{
	vec3 z = vec3(0.0);
	vec3 d = vec3(1.0);
	float r = 0.0;
	float b = 10000.0;

	for (int i = 0; i < 30; ++i) {
		if (i == NUM_ITERATIONS) {
			break;
		}
		d = EXPONENT * pow(r, EXPONENT-1.0) * d + 1.0;
		if (r > 0.0) {
			float phi = atan(z.z, z.x);
			phi *= EXPONENT;
			float theta = acos(z.y/r);
			theta *= EXPONENT;
			r = pow(r, EXPONENT);
			z = vec3(cos(phi) * cos(theta), sin(theta), sin(phi) * cos(theta)) * r;
		}
		z += pos;

		r = length(z);
		b = min(r, b);
		if (r >= 2.0) {
			break;
		}
	}
	return r * log(r) * 0.5 / length(d);
}

bool rayMarch(in vec3 pos, in vec3 dir, out float travelDist, out int steps)
{
    bool hit = false;
    travelDist = 0;
    steps = 0;

    while(!hit) { // march!
        float dist = distEst(pos);

        if(travelDist > RENDER_DIST)
            return false;

        if(dist < 0.001)
            return true;

        pos += dir * dist;
        travelDist += dist;
        steps++;

        if(steps > 100)
            return false;
    }

    return hit;
}

vec3 getPixel(in vec2 pixel_coords)
{
    const vec2 frustumRay = (pixel_coords - (0.5 * screenSize)) / camera.frustumDiv;

    // rotate frustum space to world space
    const float temp = camera.cosPitch + frustumRay.y * camera.sinPitch;
    
    vec3 rayDir = normalize(vec3(frustumRay.x * camera.cosYaw + temp * camera.sinYaw,
                                 frustumRay.y * camera.cosPitch - camera.sinPitch,
                                 temp * camera.cosYaw - frustumRay.x * camera.sinYaw));
    
    // raymarch outputs
    float theDistance = 0.0;
    int steps = 0;
    bool hit = rayMarch(camera.pos, rayDir, theDistance, steps);

    vec3 hsv = rgb2hsv(color);
    hsv.x *= time/10000.;

    return hsv2rgb(hsv) * (steps / 255.);
}

void main() {
    // get index in global work group i.e x,y position
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    
    vec4 pixel = vec4(getPixel(pixel_coords), 1);

    // output to image
    imageStore(img_output, pixel_coords, pixel);
}