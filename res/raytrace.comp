#version 430
//! layout(local_size_x = 16, local_size_y = 16) in; // this is inserted on load
layout(rgba32f, binding = 0) writeonly uniform image2D img_output;

//! #define RENDER_DIST 100

struct Camera
{
    vec3 pos;
    float cosYaw;
    float cosPitch;
    float sinYaw;
    float sinPitch;
    vec2 frustumDiv;
};

uniform Camera camera;
uniform vec2 screenSize;
uniform float time;

// default: 8, min: 0, max: 30
#define NUM_ITERATIONS 8

// default: 6.0, min: 1.0, max: 16.0
#define EXPONENT 6.0


// return no more than distance to object
float distEst(vec3 pos)
{
	vec3 z = vec3(0.0);
	vec3 d = vec3(1.0);
	float r = 0.0;
	float b = 10000.0;

	for (int i = 0; i < 30; ++i) {
		if (i == NUM_ITERATIONS) {
			break;
		}
		d = EXPONENT * pow(r, EXPONENT-1.0) * d + 1.0;
		if (r > 0.0) {
			float phi = atan(z.z, z.x);
			phi *= EXPONENT;
			float theta = acos(z.y/r);
			theta *= EXPONENT;
			r = pow(r, EXPONENT);
			z = vec3(cos(phi) * cos(theta), sin(theta), sin(phi) * cos(theta)) * r;
		}
		z += pos;

		r = length(z);
		b = min(r, b);
		if (r >= 2.0) {
			break;
		}
	}
	return r * log(r) * 0.5 / length(d);
}

bool rayMarch(in vec3 pos, in vec3 dir, out float travelDist, out int steps)
{
    bool hit = false;
    travelDist = 0;
    steps = 0;

    while(!hit) { // march!
        float dist = distEst(pos);

        if(travelDist > RENDER_DIST)
            return false;

        if(dist < 0.001)
            return true;

        pos += dir * dist;
        travelDist += dist;
        steps++;

        if(steps > 100)
            return false;
    }

    return hit;
}

vec3 getPixel(in vec2 pixel_coords)
{
    const vec2 frustumRay = (pixel_coords - (0.5 * screenSize)) / camera.frustumDiv;

    // rotate frustum space to world space
    const float temp = camera.cosPitch + frustumRay.y * camera.sinPitch;
    
    vec3 rayDir = normalize(vec3(frustumRay.x * camera.cosYaw + temp * camera.sinYaw,
                                 frustumRay.y * camera.cosPitch - camera.sinPitch,
                                 temp * camera.cosYaw - frustumRay.x * camera.sinYaw));
    
    // raymarch outputs
    float theDistance = 0.0;
    int steps = 0;
    bool hit = rayMarch(camera.pos, rayDir, theDistance, steps);

    return vec3(steps / 100.);
}

void main() {
    // get index in global work group i.e x,y position
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    
    vec4 pixel = vec4(getPixel(pixel_coords), 1);

    // output to image
    imageStore(img_output, pixel_coords, pixel);
}